From 8d5f3cd833178f386f94ad8fd428f3efa6ae0dcc Mon Sep 17 00:00:00 2001
From: Stefan Hendricks <stefan.hendricks@awi.de>
Date: Wed, 14 Jun 2017 19:34:35 +0200
Subject: [PATCH] [output] re-organization of output module

---
 pysiral/output.py | 357 +++++++++++++++++++++++-------------------------------
 1 file changed, 151 insertions(+), 206 deletions(-)

diff --git a/pysiral/output.py b/pysiral/output.py
index 4d12734..4a991a1 100644
--- a/pysiral/output.py
+++ b/pysiral/output.py
@@ -181,13 +181,13 @@ class DefaultLevel2OutputHandler(OutputHandlerBase):
         self.overwrite_protection = overwrite_protection
         self._init_product_directory()
 
-    def get_filename_from_l2(self, l2):
+    def get_filename_from_data(self, l2):
         """ Return the filename for a defined level-2 data object
         based on tag filenaming in output definition file """
         filename_template = self.output_def.filenaming
         return self.fill_template_string(filename_template, l2)
 
-    def get_directory_from_l2(self, l2, create=True):
+    def get_directory_from_data(self, l2, create=True):
         """ Return the output directory based on information provided
         in an l2 data object """
         directory = self._get_directory_from_dt(l2.info.start_time)
@@ -195,7 +195,7 @@ class DefaultLevel2OutputHandler(OutputHandlerBase):
             self._create_directory(directory)
         return directory
 
-    def get_fullpath_from_l2(self, l2):
+    def get_fullpath_from_data(self, l2):
         """ Return export path and filename based on information
         provided in the l2 data object """
         export_directory = self.get_directory_from_l2(l2)
@@ -274,6 +274,54 @@ class NCDataFile(object):
     def set_processor_settings(self, proc_settings):
         self._proc_settings = proc_settings
 
+    def set_base_export_path(self, path):
+        self.base_export_path = path
+
+    def get_full_export_path(self, startdt):
+        self._get_full_export_path(startdt)
+        return self.export_path
+
+    def _write_global_attributes(self):
+        attr_dict = self.output_handler.get_global_attribute_dict(self.data)
+        self._set_global_attributes(attr_dict)
+
+    def _populate_data_groups(self, level3=False):
+
+        dimdict = self.data.dimdict
+        dims = dimdict.keys()
+
+        for key in dims:
+                self._rootgrp.createDimension(key, dimdict[key])
+
+        for parameter_name, attribute_dict in self.output_handler.variable_def:
+
+            data = self.data.get_parameter_by_name(parameter_name)
+
+            # Convert datetime objects to number
+            if type(data[0]) is datetime:
+                data = date2num(data, self.time_def.units,
+                                self.time_def.calendar)
+
+            # Convert bool objects to integer
+            if data.dtype.str == "|b1":
+                data = np.int8(data)
+
+            # Add time axis
+            if level3 and parameter_name not in ["longitude", "latitude"]:
+                data = np.array([data])
+                dimensions = tuple(dims[0:len(data.shape)])
+            else:
+                dimensions = tuple(dims[1:len(data.shape)+1])
+
+            var = self._rootgrp.createVariable(
+                    parameter_name, data.dtype.str, dimensions, zlib=self.zlib)
+
+            var[:] = data
+
+            # Add Parameter Attributes
+            for key in attribute_dict.keys():
+                setattr(var, key, attribute_dict[key])
+
     def _create_root_group(self, attdict, **global_attr_keyw):
         """
         Create the root group and add l1b metadata as global attributes
@@ -343,239 +391,136 @@ class NCDataFile(object):
             self._rootgrp.setncattr(item, str(settings[item]))
 
     def _open_file(self):
-        self._rootgrp = Dataset(self.path, "w")
+        self._rootgrp = Dataset(self.full_path, "w")
 
     def _write_to_file(self):
         self._rootgrp.close()
 
-
-class L1bDataNC(NCDataFile):
-    """
-    Class to export a L1bdata object into a netcdf file
-    """
-
-    def __init__(self):
-        super(L1bDataNC, self).__init__()
-
-        self.datagroups = ["waveform", "surface_type", "time_orbit",
-                           "classifier", "correction"]
-        self.output_folder = None
-        self.l1b = None
-        self.parameter_attributes = get_parameter_attributes("l1b")
-
-    def export(self):
-        self._validate()
-        self._open_file()
-        # Save the l1b info data group as global attributes
-        attdict = self.l1b.info.attdict
-        self._create_root_group(attdict)
-        self._populate_data_groups()
-        self._write_to_file()
-
-    def _validate(self):
-        if self.filename is None:
-            self._create_filename()
-        self.path = os.path.join(self.output_folder, self.filename)
-
-    def _create_filename(self):
-        self.filename = file_basename(self.l1b.filename)+".nc"
-
-    def _populate_data_groups(self):
-        self._missing_parameters = []
-        for datagroup in self.datagroups:
-            if self.verbose:
-                print datagroup.upper()
-            # Create the datagroup
-            dgroup = self._rootgrp.createGroup(datagroup)
-            content = getattr(self.l1b, datagroup)
-            # Create the dimensions
-            # (must be available as OrderedDict in Datagroup Container
-            dims = content.dimdict.keys()
-            for key in dims:
-                dgroup.createDimension(key, content.dimdict[key])
-            # Now add variables for each parameter in datagroup
-            for parameter in content.parameter_list:
-                data = getattr(content, parameter)
-                # Convert datetime objects to number
-                if type(data[0]) is datetime:
-                    data = date2num(data, self.time_def.units,
-                                    self.time_def.calendar)
-                # Convert bool objects to integer
-                if data.dtype.str == "|b1":
-                    data = np.int8(data)
-                dimensions = tuple(dims[0:len(data.shape)])
-                if self.verbose:
-                    print " "+parameter, dimensions, data.dtype.str, data.shape
-                var = dgroup.createVariable(
-                    parameter, data.dtype.str, dimensions, zlib=self.zlib)
-                var[:] = data
-                # Add Parameter Attributes
-                attribute_dict = self._get_variable_attr_dict(parameter)
-                for key in attribute_dict.keys():
-                    setattr(var, key, attribute_dict[key])
-
-        # Report mission variable attributes (not in master release)
-        not_master = "master" not in PYSIRAL_VERSION
-        if not_master:
-            print "Warning: Missing parameter attributes for "+"; ".join(
-                self._missing_parameters)
-
-
-class Level2Output(NCDataFile):
-    """
-    Class to export a l2data object into a netcdf file
-    """
-
-    def __init__(self, l2, output_handler):
-        super(Level2Output, self).__init__()
-        self.l2 = l2
-        self.output_handler = output_handler
-        self._export_l2()
-
-    def set_base_export_path(self, path):
-        self.base_export_path = path
-
-    def get_full_export_path(self, startdt):
-        self._get_full_export_path(startdt)
-        return self.export_path
-
-    def _export_l2(self):
-        self.path = self.full_path
-        self._open_file()
-        self._write_global_attributes()
-        self._populate_data_groups()
-        self._write_to_file()
-
-    def _write_global_attributes(self):
-        attr_dict = self.output_handler.get_global_attribute_dict(self.l2)
-        self._set_global_attributes(attr_dict)
-
-    def _populate_data_groups(self):
-
-        dimdict = self.l2.dimdict
-        dims = dimdict.keys()
-
-        for key in dims:
-                self._rootgrp.createDimension(key, dimdict[key])
-
-        for parameter_name, attribute_dict in self.output_handler.variable_def:
-
-            data = self.l2.get_parameter_by_name(parameter_name)
-
-            # Convert datetime objects to number
-            if type(data[0]) is datetime:
-                data = date2num(data, self.time_def.units,
-                                self.time_def.calendar)
-
-            # Convert bool objects to integer
-            if data.dtype.str == "|b1":
-                data = np.int8(data)
-
-            dimensions = tuple(dims[0:len(data.shape)])
-            var = self._rootgrp.createVariable(
-                    parameter_name, data.dtype.str, dimensions, zlib=self.zlib)
-            var[:] = data
-
-            # Add Parameter Attributes
-            for key in attribute_dict.keys():
-                setattr(var, key, attribute_dict[key])
-
     @property
     def export_path(self):
         """ Evoking this property will also create the directory if it
         does not already exists """
-        return self.output_handler.get_directory_from_l2(self.l2, create=True)
+        return self.output_handler.get_directory_from_data(self.data,
+                                                           create=True)
 
     @property
     def export_filename(self):
         """ Returns the filename for the level2 output file """
-        return self.output_handler.get_filename_from_l2(self.l2)
+        return self.output_handler.get_filename_from_data(self.data)
 
     @property
     def full_path(self):
         return os.path.join(self.export_path, self.export_filename)
 
+#class L1bDataNC(NCDataFile):
+#    """
+#    Class to export a L1bdata object into a netcdf file
+#    """
+#
+#    def __init__(self):
+#        super(L1bDataNC, self).__init__()
+#
+#        self.datagroups = ["waveform", "surface_type", "time_orbit",
+#                           "classifier", "correction"]
+#        self.output_folder = None
+#        self.l1b = None
+#        self.parameter_attributes = get_parameter_attributes("l1b")
+#
+#    def export(self):
+#        self._validate()
+#        self._open_file()
+#        # Save the l1b info data group as global attributes
+#        attdict = self.l1b.info.attdict
+#        self._create_root_group(attdict)
+#        self._populate_data_groups()
+#        self._write_to_file()
+#
+#    def _validate(self):
+#        if self.filename is None:
+#            self._create_filename()
+#        self.path = os.path.join(self.output_folder, self.filename)
+#
+#    def _create_filename(self):
+#        self.filename = file_basename(self.l1b.filename)+".nc"
+#
+#    def _populate_data_groups(self):
+#        self._missing_parameters = []
+#        for datagroup in self.datagroups:
+#            if self.verbose:
+#                print datagroup.upper()
+#            # Create the datagroup
+#            dgroup = self._rootgrp.createGroup(datagroup)
+#            content = getattr(self.l1b, datagroup)
+#            # Create the dimensions
+#            # (must be available as OrderedDict in Datagroup Container
+#            dims = content.dimdict.keys()
+#            for key in dims:
+#                dgroup.createDimension(key, content.dimdict[key])
+#            # Now add variables for each parameter in datagroup
+#            for parameter in content.parameter_list:
+#                data = getattr(content, parameter)
+#                # Convert datetime objects to number
+#                if type(data[0]) is datetime:
+#                    data = date2num(data, self.time_def.units,
+#                                    self.time_def.calendar)
+#                # Convert bool objects to integer
+#                if data.dtype.str == "|b1":
+#                    data = np.int8(data)
+#                dimensions = tuple(dims[0:len(data.shape)])
+#                if self.verbose:
+#                    print " "+parameter, dimensions, data.dtype.str, data.shape
+#                var = dgroup.createVariable(
+#                    parameter, data.dtype.str, dimensions, zlib=self.zlib)
+#                var[:] = data
+#                # Add Parameter Attributes
+#                attribute_dict = self._get_variable_attr_dict(parameter)
+#                for key in attribute_dict.keys():
+#                    setattr(var, key, attribute_dict[key])
+#
+#        # Report mission variable attributes (not in master release)
+#        not_master = "master" not in PYSIRAL_VERSION
+#        if not_master:
+#            print "Warning: Missing parameter attributes for "+"; ".join(
+#                self._missing_parameters)
 
-class L3SDataNC(NCDataFile):
+
+class Level2Output(NCDataFile):
     """
     Class to export a l2data object into a netcdf file
     """
 
-    def __init__(self):
-        super(L3SDataNC, self).__init__()
-        self.parameter = []
-        self.export_path = None
-        self.metadata = None
-        self.l2 = None
-        self.parameter_attributes = get_parameter_attributes("l3c")
-
-    def set_export_folder(self, path):
-        self.export_path = path
-
-    def set_metadata(self, metadata):
-        self.metadata = metadata
+    def __init__(self, data, output_handler):
+        super(Level2Output, self).__init__()
+        self.data = data
+        self.output_handler = output_handler
+        self._export_content()
 
-    def export(self, l3):
-        self._validate()
+    def _export_content(self):
+        self.path = self.full_path
         self._open_file()
-        self._create_root_group(self.metadata.attdict)
-        self._populate_data_groups(l3)
-        self._add_time_dummy_variable()
+        self._write_global_attributes()
+        self._populate_data_groups()
         self._write_to_file()
 
-    def export_parameter_dict(self, pardict, dimdict=None):
-        self._validate()
+
+class Level3Output(NCDataFile):
+    """ Class to export a Level-3 data object into a netcdf file.
+    Differences to Level2Output are small but substantial (e.g.
+    with the additional time dimension) """
+
+    def __init__(self, data, output_handler):
+        super(Level3Output, self).__init__()
+        self.data = data
+        self.output_handler = output_handler
+        self._export_content()
+
+    def _export_content(self):
         self._open_file()
-        self._create_root_group(self.metadata.attdict)
+        self._write_global_attributes()
+        self._populate_data_groups(level3=True)
         self._add_time_dummy_variable()
-        self._populate_data_groups_from_dict(pardict, dimdict)
         self._write_to_file()
 
-    def _validate(self):
-        # Validate the export directory
-        path = self.export_path
-        validate_directory(path)
-        # get full output filename
-        filenaming = PysiralOutputFilenaming()
-        filename = filenaming.from_l3s(self.metadata)
-        self.path = os.path.join(path, filename)
-
-    def _populate_data_groups(self, l3):
-        dimdict = l3.dimdict
-        dims = dimdict.keys()
-        for key in dims:
-                self._rootgrp.createDimension(key, dimdict[key])
-        for parameter_name in l3.parameter_list:
-            data = l3.get_parameter_by_name(parameter_name)
-            # Add time axis
-            if parameter_name not in ["lon", "lat"]:
-                data = np.array([data])
-                dimensions = tuple(dims[0:len(data.shape)])
-            else:
-                dimensions = tuple(dims[1:len(data.shape)+1])
-            var = self._rootgrp.createVariable(
-                    parameter_name, data.dtype.str, dimensions, zlib=self.zlib)
-            var[:] = data
-            # Add Parameter Attributes
-            attribute_dict = self._get_variable_attr_dict(parameter_name)
-            for key in attribute_dict.keys():
-                setattr(var, key, attribute_dict[key])
-
-    def _populate_data_groups_from_dict(self, pardict, dimdict):
-        dims = dimdict.keys()
-        for key in dims:
-                self._rootgrp.createDimension(key, dimdict[key])
-        for parameter_name in sorted(pardict.keys()):
-            data = pardict[parameter_name]
-            dimensions = tuple(dims[0:len(data.shape)])
-            var = self._rootgrp.createVariable(
-                    parameter_name, data.dtype.str, dimensions, zlib=self.zlib)
-            var[:] = np.array([data])
-            # Add Parameter Attributes
-            attribute_dict = self._get_variable_attr_dict(parameter_name)
-            for key in attribute_dict.keys():
-                setattr(var, key, attribute_dict[key])
-
     def _add_time_dummy_variable(self):
         var = self._rootgrp.createVariable("time", "f8", ('time'),
                                            zlib=self.zlib)
-- 
2.8.1.windows.1

